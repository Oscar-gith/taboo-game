# CLAUDE.md — Taboo Game

> Project context for Claude Code sessions. Read this before making any changes.

---

## Project Summary

Real-time online multiplayer Taboo card game in Spanish. Players join rooms via 6-char codes,
form teams, and take turns describing Spanish words. Cards are generated by the Google Gemini API.

## Tech Stack (Do Not Change Without Discussion)

| Layer | Technology | Why |
|---|---|---|
| Frontend | Plain HTML + CSS + JS | No build tools needed; educational simplicity |
| Backend | Node.js + Express + Socket.io | Real-time events; familiar for JS developers |
| Cards | Google Gemini API (gemini-1.5-flash) | Free tier, fast Spanish card generation |
| Auth | None (nickname only) | Party game; friction-free joining |
| DB | None (in-memory) | Rooms expire; no persistence needed |

## Project Structure

```
taboo-game/
├── SPEC.md          ← READ THIS FIRST — game rules and behavior
├── CLAUDE.md        ← This file — project context
├── server/          ← All backend code (Node.js, CommonJS)
│   ├── index.js     ← Express server + Socket.io event wiring
│   ├── gameRoom.js  ← Core game state machine (most important file)
│   ├── gameManager.js ← Room registry
│   ├── cardGenerator.js ← Google Gemini API integration
│   ├── cardStore.js ← Deck management
│   └── config.js    ← Constants
├── client/          ← All frontend code (served statically by Express)
│   ├── index.html   ← Single page; all screens are toggled <div>s
│   ├── style.css    ← Mobile-first styles
│   └── game.js      ← All client logic + Socket.io handlers
├── data/
│   └── cards-seed.json ← Pre-generated fallback deck (Spanish cards)
└── .claude/
    └── commands/    ← Custom Claude Code slash commands
```

## Key Architectural Decisions

1. **Server-authoritative state**: All game logic lives in `server/gameRoom.js`. The client
   only renders what the server sends. Never implement game rules on the client side.

2. **Card secrecy**: The current card is sent ONLY to the describer's socket ID via
   `socket.to(describerSocketId).emit('card_revealed', { card })`. Never broadcast cards
   to the room. Non-describer clients show a "card hidden" view.

3. **Server-side timer**: The 60-second countdown runs via `setInterval` on the server.
   Server broadcasts `timer_tick` every second. Clients display server time, not local time.
   This prevents cheating and keeps all players in sync.

4. **Single HTML page**: All 7 game screens are `<div>` elements toggled with CSS
   `display: none/block`. No routing library. Screen navigation lives in `client/game.js`
   via the `showScreen(id)` function.

5. **No ES modules on server**: Use `require()` / `module.exports` (CommonJS). Node.js
   does not need `"type": "module"` in package.json.

6. **Persistent playerId**: Each player gets a UUID stored in `sessionStorage`. This survives
   page refreshes but not tab closes. It's used to reconnect players after disconnection.

7. **Global shared deck**: All rooms share the same card deck loaded from `cardStore.js`.
   Cards are drawn uniquely per game (tracked in `gameRoom.js`). Low deck triggers auto-generation.

## Development Commands

```bash
npm start          # Production server
npm run dev        # Auto-restart server on file changes (uses nodemon)
npm run generate-cards  # Generate a new Spanish card pack via Gemini API
```

Server runs on `http://localhost:3000` by default.

## Environment Variables

Copy `.env.example` to `.env` and fill in:

```
GOOGLE_API_KEY=your-key-here   # Required for card generation (get at aistudio.google.com)
PORT=3000                       # Optional, defaults to 3000
```

## How Card Generation Works

1. `server/cardGenerator.js` calls the Google Gemini API (gemini-1.5-flash)
2. Prompt requests N Spanish Taboo cards as a raw JSON array
3. Response is parsed, UUIDs are assigned, and cards are validated
4. `server/cardStore.js` maintains the global deck in memory
5. When deck drops below `LOW_DECK_THRESHOLD` (10 cards), generation is triggered
6. `data/cards-seed.json` is used as the initial deck on server start

## Socket.io Pattern

Every socket handler in `server/index.js` follows this pattern:
```
1. Look up room via gameManager.getRoom(roomCode)
2. Validate: room exists, player is authorized for this action, game state is correct
3. Call the appropriate method on gameRoom
4. Broadcast the result back to the room
5. On error: socket.emit('error', { code, message })
```

## Coding Conventions

- **Server**: CommonJS (`require`/`module.exports`), no TypeScript, no decorators
- **Client**: `const`/`let`, arrow functions, no framework, no bundler
- **Naming**: camelCase for variables/functions, PascalCase for classes
- **Errors**: Always emit `error` event back to client with `{ code, message }`
- **Comments**: Explain WHY non-obvious decisions were made, not what the code does
- **No magic numbers**: Put all game constants in `server/config.js`

## Bug & Backlog Management — GitHub Issues

**NO usar archivos markdown para gestionar bugs o backlog.** Usar GitHub Issues exclusivamente.

```bash
# Listar bugs abiertos
gh issue list --label bug

# Reportar un nuevo bug
gh issue create --title "Título del bug" --body "Descripción" --label bug

# Ver detalles de un issue
gh issue view 123

# Cerrar un bug resuelto
gh issue close 123 --comment "Resuelto en commit abc1234"
```

El archivo `BACKLOG.md` es solo para documentar features futuras de referencia, no para tracking activo.

Use el comando `/bug` para gestionar bugs via GitHub Issues.

---

## When Adding New Features — SDD Workflow

1. **Read SPEC.md** — does this feature conflict with anything?
2. **Update SPEC.md first** — describe the new behavior, state transitions, and Socket.io events
3. **Get the spec update reviewed** — present to user before writing code
4. **Implement**: config.js → gameRoom.js → index.js → index.html → style.css → game.js
5. **Provide a test checklist** after implementation

Use the `/new-feature` slash command to be guided through this workflow.

## Files to Read First (New Session Order)

1. `SPEC.md` — what the game does
2. `server/gameRoom.js` — how the core state machine works
3. `server/index.js` — how socket events are wired
4. `client/game.js` — how the client handles events and navigates screens

## Common Pitfalls to Avoid

- Never put game logic in `client/game.js` — client is display-only
- Never broadcast the current card to the whole room
- Never use socket IDs as persistent player identifiers (they change on reconnect)
- Always normalize room codes to uppercase: `roomCode.toUpperCase()`
- Timer must run on the server, not the client
- Always validate that the player is authorized for each action (correct role, correct turn)
